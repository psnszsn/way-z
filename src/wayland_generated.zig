// Generated by zig-wayland-2

// Copyright © 2008-2011 Kristian Høgsberg
// Copyright © 2010-2011 Intel Corporation
// Copyright © 2012-2013 Collabora, Ltd.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice (including the
// next paragraph) shall be included in all copies or substantial
// portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

const std = @import("std");
const os = std.os;
const Proxy = @import("proxy.zig").Proxy;
const Argument = @import("argument.zig").Argument;
const Fixed = @import("argument.zig").Fixed;
pub const Display = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Error = enum(c_int) {
        invalid_object = 0,
        invalid_method = 1,
        no_memory = 2,
        implementation = 3,
        _,
    };
    pub const Event = union(enum) {
        @"error": struct {
            object_id: ?*anyopaque,
            code: u32,
            message: [*:0]const u8,
        },
        delete_id: struct {
            id: u32,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Display,
        comptime T: type,
        comptime _listener: fn (display: *Display, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Display,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn sync(self: *Display) !*Callback {
        var _args = [_]Argument{
            .{ .new_id = 0 },
        };
        return self.proxy.marshal_request_constructor(Callback, 0, &_args);
    }
    pub fn getRegistry(self: *Display) !*Registry {
        var _args = [_]Argument{
            .{ .new_id = 0 },
        };
        return self.proxy.marshal_request_constructor(Registry, 1, &_args);
    }
    pub fn destroy(self: *Display) void {
        self.proxy.destroy();
    }
};
pub const Registry = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Event = union(enum) {
        global: struct {
            name: u32,
            interface: [*:0]const u8,
            version: u32,
        },
        global_remove: struct {
            name: u32,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Registry,
        comptime T: type,
        comptime _listener: fn (registry: *Registry, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Registry,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn bind(self: *Registry, _name: u32, comptime T: type, _version: u32) !*T {
        var _args = [_]Argument{
            .{ .uint = _name },
            .{ .new_id = 0 },
        };
        _ = _version;
        return self.proxy.marshal_request_constructor(T, 0, &_args);
    }
    pub fn destroy(self: *Registry) void {
        self.proxy.destroy();
    }
};
pub const Callback = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Event = union(enum) {
        done: struct {
            callback_data: u32,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Callback,
        comptime T: type,
        comptime _listener: fn (callback: *Callback, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Callback,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn destroy(self: *Callback) void {
        self.proxy.destroy();
    }
};
pub const Buffer = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Event = union(enum) {
        release: void,
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Buffer,
        comptime T: type,
        comptime _listener: fn (buffer: *Buffer, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Buffer,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn destroy(self: *Buffer) void {
        self.proxy.marshal(0, null);
        // self.proxy.destroy();
    }
};
pub const Compositor = struct {
    proxy: Proxy,
    pub const generated_version = 6;
};
pub const Surface = struct {
    proxy: Proxy,
    pub const generated_version = 6;
    pub const Error = enum(c_int) {
        invalid_scale = 0,
        invalid_transform = 1,
        invalid_size = 2,
        invalid_offset = 3,
        defunct_role_object = 4,
        _,
    };
    pub const Event = union(enum) {
        enter: struct {
            output: ?*Output,
        },
        leave: struct {
            output: ?*Output,
        },
        preferred_buffer_scale: struct {
            factor: i32,
        },
        preferred_buffer_transform: struct {
            transform: Output.Transform,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Surface,
        comptime T: type,
        comptime _listener: fn (surface: *Surface, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Surface,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn destroy(self: *Surface) void {
        self.proxy.marshal(0, null);
        // self.proxy.destroy();
    }
    pub fn attach(self: *Surface, _buffer: ?*Buffer, _x: i32, _y: i32) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_buffer) },
            .{ .int = _x },
            .{ .int = _y },
        };
        self.proxy.marshal(1, &_args);
    }
    pub fn damage(self: *Surface, _x: i32, _y: i32, _width: i32, _height: i32) void {
        var _args = [_]Argument{
            .{ .int = _x },
            .{ .int = _y },
            .{ .int = _width },
            .{ .int = _height },
        };
        self.proxy.marshal(2, &_args);
    }
    pub fn frame(self: *Surface) !*Callback {
        var _args = [_]Argument{
            .{ .new_id = 0 },
        };
        return self.proxy.marshal_request_constructor(Callback, 3, &_args);
    }
    pub fn setOpaqueRegion(self: *Surface, _region: ?*Region) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_region) },
        };
        self.proxy.marshal(4, &_args);
    }
    pub fn setInputRegion(self: *Surface, _region: ?*Region) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_region) },
        };
        self.proxy.marshal(5, &_args);
    }
    pub fn commit(self: *Surface) void {
        self.proxy.marshal(6, null);
    }
    pub fn setBufferTransform(self: *Surface, _transform: Output.Transform) void {
        var _args = [_]Argument{
            .{ .int = _transform },
        };
        self.proxy.marshal(7, &_args);
    }
    pub fn setBufferScale(self: *Surface, _scale: i32) void {
        var _args = [_]Argument{
            .{ .int = _scale },
        };
        self.proxy.marshal(8, &_args);
    }
    pub fn damageBuffer(self: *Surface, _x: i32, _y: i32, _width: i32, _height: i32) void {
        var _args = [_]Argument{
            .{ .int = _x },
            .{ .int = _y },
            .{ .int = _width },
            .{ .int = _height },
        };
        self.proxy.marshal(9, &_args);
    }
    pub fn offset(self: *Surface, _x: i32, _y: i32) void {
        var _args = [_]Argument{
            .{ .int = _x },
            .{ .int = _y },
        };
        self.proxy.marshal(10, &_args);
    }
};
pub const Region = struct {
    proxy: Proxy,
    pub const generated_version = 1;
};
pub const Shm = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Error = enum(c_int) {
        invalid_format = 0,
        invalid_stride = 1,
        invalid_fd = 2,
        _,
    };
    pub const Format = enum(c_int) {
        argb8888 = 0,
        xrgb8888 = 1,
        c8 = 0x20203843,
        rgb332 = 0x38424752,
        bgr233 = 0x38524742,
        xrgb4444 = 0x32315258,
        xbgr4444 = 0x32314258,
        rgbx4444 = 0x32315852,
        bgrx4444 = 0x32315842,
        argb4444 = 0x32315241,
        abgr4444 = 0x32314241,
        rgba4444 = 0x32314152,
        bgra4444 = 0x32314142,
        xrgb1555 = 0x35315258,
        xbgr1555 = 0x35314258,
        rgbx5551 = 0x35315852,
        bgrx5551 = 0x35315842,
        argb1555 = 0x35315241,
        abgr1555 = 0x35314241,
        rgba5551 = 0x35314152,
        bgra5551 = 0x35314142,
        rgb565 = 0x36314752,
        bgr565 = 0x36314742,
        rgb888 = 0x34324752,
        bgr888 = 0x34324742,
        xbgr8888 = 0x34324258,
        rgbx8888 = 0x34325852,
        bgrx8888 = 0x34325842,
        abgr8888 = 0x34324241,
        rgba8888 = 0x34324152,
        bgra8888 = 0x34324142,
        xrgb2101010 = 0x30335258,
        xbgr2101010 = 0x30334258,
        rgbx1010102 = 0x30335852,
        bgrx1010102 = 0x30335842,
        argb2101010 = 0x30335241,
        abgr2101010 = 0x30334241,
        rgba1010102 = 0x30334152,
        bgra1010102 = 0x30334142,
        yuyv = 0x56595559,
        yvyu = 0x55595659,
        uyvy = 0x59565955,
        vyuy = 0x59555956,
        ayuv = 0x56555941,
        nv12 = 0x3231564e,
        nv21 = 0x3132564e,
        nv16 = 0x3631564e,
        nv61 = 0x3136564e,
        yuv410 = 0x39565559,
        yvu410 = 0x39555659,
        yuv411 = 0x31315559,
        yvu411 = 0x31315659,
        yuv420 = 0x32315559,
        yvu420 = 0x32315659,
        yuv422 = 0x36315559,
        yvu422 = 0x36315659,
        yuv444 = 0x34325559,
        yvu444 = 0x34325659,
        r8 = 0x20203852,
        r16 = 0x20363152,
        rg88 = 0x38384752,
        gr88 = 0x38385247,
        rg1616 = 0x32334752,
        gr1616 = 0x32335247,
        xrgb16161616f = 0x48345258,
        xbgr16161616f = 0x48344258,
        argb16161616f = 0x48345241,
        abgr16161616f = 0x48344241,
        xyuv8888 = 0x56555958,
        vuy888 = 0x34325556,
        vuy101010 = 0x30335556,
        y210 = 0x30313259,
        y212 = 0x32313259,
        y216 = 0x36313259,
        y410 = 0x30313459,
        y412 = 0x32313459,
        y416 = 0x36313459,
        xvyu2101010 = 0x30335658,
        xvyu12_16161616 = 0x36335658,
        xvyu16161616 = 0x38345658,
        y0l0 = 0x304c3059,
        x0l0 = 0x304c3058,
        y0l2 = 0x324c3059,
        x0l2 = 0x324c3058,
        yuv420_8bit = 0x38305559,
        yuv420_10bit = 0x30315559,
        xrgb8888_a8 = 0x38415258,
        xbgr8888_a8 = 0x38414258,
        rgbx8888_a8 = 0x38415852,
        bgrx8888_a8 = 0x38415842,
        rgb888_a8 = 0x38413852,
        bgr888_a8 = 0x38413842,
        rgb565_a8 = 0x38413552,
        bgr565_a8 = 0x38413542,
        nv24 = 0x3432564e,
        nv42 = 0x3234564e,
        p210 = 0x30313250,
        p010 = 0x30313050,
        p012 = 0x32313050,
        p016 = 0x36313050,
        axbxgxrx106106106106 = 0x30314241,
        nv15 = 0x3531564e,
        q410 = 0x30313451,
        q401 = 0x31303451,
        xrgb16161616 = 0x38345258,
        xbgr16161616 = 0x38344258,
        argb16161616 = 0x38345241,
        abgr16161616 = 0x38344241,
        _,
    };
    pub const Event = union(enum) {
        format: struct {
            format: Format,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Shm,
        comptime T: type,
        comptime _listener: fn (shm: *Shm, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Shm,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn createPool(self: *Shm, _fd: i32, _size: i32) !*ShmPool {
        var _args = [_]Argument{
            .{ .new_id = 0 },
            .{ .fd = _fd },
            .{ .int = _size },
        };
        return self.proxy.marshal_request_constructor(ShmPool, 0, &_args);
    }
    pub fn destroy(self: *Shm) void {
        self.proxy.destroy();
    }
};
pub const ShmPool = struct {
    proxy: Proxy,
    pub const generated_version = 1;
};
pub const DataDeviceManager = struct {
    proxy: Proxy,
    pub const generated_version = 3;
    pub const DndAction = packed struct(u32) {
        copy: bool = false,
        move: bool = false,
        ask: bool = false,
        _padding: u29 = 0,
        pub const Enum = enum(c_int) {
            none = 0,
            copy = 1,
            move = 2,
            ask = 4,
            _,
        };
    };
};
pub const DataSource = struct {
    proxy: Proxy,
    pub const generated_version = 3;
    pub const Error = enum(c_int) {
        invalid_action_mask = 0,
        invalid_source = 1,
        _,
    };
    pub const Event = union(enum) {
        target: struct {
            mime_type: ?[*:0]const u8,
        },
        send: struct {
            mime_type: [*:0]const u8,
            fd: i32,
        },
        cancelled: void,
        dnd_drop_performed: void,
        dnd_finished: void,
        action: struct {
            dnd_action: DataDeviceManager.DndAction,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *DataSource,
        comptime T: type,
        comptime _listener: fn (data_source: *DataSource, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            DataSource,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn offer(self: *DataSource, _mime_type: [*:0]const u8) void {
        var _args = [_]Argument{
            .{ .string = _mime_type },
        };
        self.proxy.marshal(0, &_args);
    }
    pub fn destroy(self: *DataSource) void {
        self.proxy.marshal(1, null);
        // self.proxy.destroy();
    }
    pub fn setActions(self: *DataSource, _dnd_actions: DataDeviceManager.DndAction) void {
        var _args = [_]Argument{
            .{ .uint = _dnd_actions },
        };
        self.proxy.marshal(2, &_args);
    }
};
pub const DataDevice = struct {
    proxy: Proxy,
    pub const generated_version = 3;
    pub const Error = enum(c_int) {
        role = 0,
        _,
    };
    pub const Event = union(enum) {
        data_offer: struct {
            id: *DataOffer,
        },
        enter: struct {
            serial: u32,
            surface: ?*Surface,
            x: Fixed,
            y: Fixed,
            id: ?*DataOffer,
        },
        leave: void,
        motion: struct {
            time: u32,
            x: Fixed,
            y: Fixed,
        },
        drop: void,
        selection: struct {
            id: ?*DataOffer,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *DataDevice,
        comptime T: type,
        comptime _listener: fn (data_device: *DataDevice, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            DataDevice,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn startDrag(self: *DataDevice, _source: ?*DataSource, _origin: *Surface, _icon: ?*Surface, _serial: u32) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_source) },
            .{ .o = @ptrCast(_origin) },
            .{ .o = @ptrCast(_icon) },
            .{ .uint = _serial },
        };
        self.proxy.marshal(0, &_args);
    }
    pub fn setSelection(self: *DataDevice, _source: ?*DataSource, _serial: u32) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_source) },
            .{ .uint = _serial },
        };
        self.proxy.marshal(1, &_args);
    }
    pub fn release(self: *DataDevice) void {
        self.proxy.marshal(2, null);
        // self.proxy.destroy();
    }
    pub fn destroy(self: *DataDevice) void {
        self.proxy.destroy();
    }
};
pub const DataOffer = struct {
    proxy: Proxy,
    pub const generated_version = 3;
    pub const Error = enum(c_int) {
        invalid_finish = 0,
        invalid_action_mask = 1,
        invalid_action = 2,
        invalid_offer = 3,
        _,
    };
    pub const Event = union(enum) {
        offer: struct {
            mime_type: [*:0]const u8,
        },
        source_actions: struct {
            source_actions: DataDeviceManager.DndAction,
        },
        action: struct {
            dnd_action: DataDeviceManager.DndAction,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *DataOffer,
        comptime T: type,
        comptime _listener: fn (data_offer: *DataOffer, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            DataOffer,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn accept(self: *DataOffer, _serial: u32, _mime_type: ?[*:0]const u8) void {
        var _args = [_]Argument{
            .{ .uint = _serial },
            .{ .string = _mime_type },
        };
        self.proxy.marshal(0, &_args);
    }
    pub fn receive(self: *DataOffer, _mime_type: [*:0]const u8, _fd: i32) void {
        var _args = [_]Argument{
            .{ .string = _mime_type },
            .{ .fd = _fd },
        };
        self.proxy.marshal(1, &_args);
    }
    pub fn destroy(self: *DataOffer) void {
        self.proxy.marshal(2, null);
        // self.proxy.destroy();
    }
    pub fn finish(self: *DataOffer) void {
        self.proxy.marshal(3, null);
    }
    pub fn setActions(self: *DataOffer, _dnd_actions: DataDeviceManager.DndAction, _preferred_action: DataDeviceManager.DndAction) void {
        var _args = [_]Argument{
            .{ .uint = _dnd_actions },
            .{ .uint = _preferred_action },
        };
        self.proxy.marshal(4, &_args);
    }
};
pub const Shell = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Error = enum(c_int) {
        role = 0,
        _,
    };
};
pub const ShellSurface = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Resize = packed struct(u32) {
        top: bool = false,
        bottom: bool = false,
        left: bool = false,
        right: bool = false,
        _padding: u28 = 0,
        pub const Enum = enum(c_int) {
            none = 0,
            top = 1,
            bottom = 2,
            left = 4,
            top_left = 5,
            bottom_left = 6,
            right = 8,
            top_right = 9,
            bottom_right = 10,
            _,
        };
    };
    pub const Transient = packed struct(u32) {
        inactive: bool = false,
        _padding: u31 = 0,
        pub const Enum = enum(c_int) {
            inactive = 0x1,
            _,
        };
    };
    pub const FullscreenMethod = enum(c_int) {
        default = 0,
        scale = 1,
        driver = 2,
        fill = 3,
        _,
    };
    pub const Event = union(enum) {
        ping: struct {
            serial: u32,
        },
        configure: struct {
            edges: Resize,
            width: i32,
            height: i32,
        },
        popup_done: void,
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *ShellSurface,
        comptime T: type,
        comptime _listener: fn (shell_surface: *ShellSurface, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            ShellSurface,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn pong(self: *ShellSurface, _serial: u32) void {
        var _args = [_]Argument{
            .{ .uint = _serial },
        };
        self.proxy.marshal(0, &_args);
    }
    pub fn move(self: *ShellSurface, _seat: *Seat, _serial: u32) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_seat) },
            .{ .uint = _serial },
        };
        self.proxy.marshal(1, &_args);
    }
    pub fn resize(self: *ShellSurface, _seat: *Seat, _serial: u32, _edges: Resize) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_seat) },
            .{ .uint = _serial },
            .{ .uint = _edges },
        };
        self.proxy.marshal(2, &_args);
    }
    pub fn setToplevel(self: *ShellSurface) void {
        self.proxy.marshal(3, null);
    }
    pub fn setTransient(self: *ShellSurface, _parent: *Surface, _x: i32, _y: i32, _flags: Transient) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_parent) },
            .{ .int = _x },
            .{ .int = _y },
            .{ .uint = _flags },
        };
        self.proxy.marshal(4, &_args);
    }
    pub fn setFullscreen(self: *ShellSurface, _method: FullscreenMethod, _framerate: u32, _output: ?*Output) void {
        var _args = [_]Argument{
            .{ .uint = _method },
            .{ .uint = _framerate },
            .{ .o = @ptrCast(_output) },
        };
        self.proxy.marshal(5, &_args);
    }
    pub fn setPopup(self: *ShellSurface, _seat: *Seat, _serial: u32, _parent: *Surface, _x: i32, _y: i32, _flags: Transient) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_seat) },
            .{ .uint = _serial },
            .{ .o = @ptrCast(_parent) },
            .{ .int = _x },
            .{ .int = _y },
            .{ .uint = _flags },
        };
        self.proxy.marshal(6, &_args);
    }
    pub fn setMaximized(self: *ShellSurface, _output: ?*Output) void {
        var _args = [_]Argument{
            .{ .o = @ptrCast(_output) },
        };
        self.proxy.marshal(7, &_args);
    }
    pub fn setTitle(self: *ShellSurface, _title: [*:0]const u8) void {
        var _args = [_]Argument{
            .{ .string = _title },
        };
        self.proxy.marshal(8, &_args);
    }
    pub fn setClass(self: *ShellSurface, _class_: [*:0]const u8) void {
        var _args = [_]Argument{
            .{ .string = _class_ },
        };
        self.proxy.marshal(9, &_args);
    }
    pub fn destroy(self: *ShellSurface) void {
        self.proxy.destroy();
    }
};
pub const Seat = struct {
    proxy: Proxy,
    pub const generated_version = 9;
    pub const Capability = packed struct(u32) {
        pointer: bool = false,
        keyboard: bool = false,
        touch: bool = false,
        _padding: u29 = 0,
        pub const Enum = enum(c_int) {
            pointer = 1,
            keyboard = 2,
            touch = 4,
            _,
        };
    };
    pub const Error = enum(c_int) {
        missing_capability = 0,
        _,
    };
    pub const Event = union(enum) {
        capabilities: struct {
            capabilities: Capability,
        },
        name: struct {
            name: [*:0]const u8,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Seat,
        comptime T: type,
        comptime _listener: fn (seat: *Seat, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Seat,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn getPointer(self: *Seat) !*Pointer {
        var _args = [_]Argument{
            .{ .new_id = 0 },
        };
        return self.proxy.marshal_request_constructor(Pointer, 0, &_args);
    }
    pub fn getKeyboard(self: *Seat) !*Keyboard {
        var _args = [_]Argument{
            .{ .new_id = 0 },
        };
        return self.proxy.marshal_request_constructor(Keyboard, 1, &_args);
    }
    pub fn getTouch(self: *Seat) !*Touch {
        var _args = [_]Argument{
            .{ .new_id = 0 },
        };
        return self.proxy.marshal_request_constructor(Touch, 2, &_args);
    }
    pub fn release(self: *Seat) void {
        self.proxy.marshal(3, null);
        // self.proxy.destroy();
    }
    pub fn destroy(self: *Seat) void {
        self.proxy.destroy();
    }
};
pub const Pointer = struct {
    proxy: Proxy,
    pub const generated_version = 9;
    pub const Error = enum(c_int) {
        role = 0,
        _,
    };
    pub const ButtonState = enum(c_int) {
        released = 0,
        pressed = 1,
        _,
    };
    pub const Axis = enum(c_int) {
        vertical_scroll = 0,
        horizontal_scroll = 1,
        _,
    };
    pub const AxisSource = enum(c_int) {
        wheel = 0,
        finger = 1,
        continuous = 2,
        wheel_tilt = 3,
        _,
    };
    pub const AxisRelativeDirection = enum(c_int) {
        identical = 0,
        inverted = 1,
        _,
    };
    pub const Event = union(enum) {
        enter: struct {
            serial: u32,
            surface: ?*Surface,
            surface_x: Fixed,
            surface_y: Fixed,
        },
        leave: struct {
            serial: u32,
            surface: ?*Surface,
        },
        motion: struct {
            time: u32,
            surface_x: Fixed,
            surface_y: Fixed,
        },
        button: struct {
            serial: u32,
            time: u32,
            button: u32,
            state: ButtonState,
        },
        axis: struct {
            time: u32,
            axis: Axis,
            value: Fixed,
        },
        frame: void,
        axis_source: struct {
            axis_source: AxisSource,
        },
        axis_stop: struct {
            time: u32,
            axis: Axis,
        },
        axis_discrete: struct {
            axis: Axis,
            discrete: i32,
        },
        axis_value120: struct {
            axis: Axis,
            value120: i32,
        },
        axis_relative_direction: struct {
            axis: Axis,
            direction: AxisRelativeDirection,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Pointer,
        comptime T: type,
        comptime _listener: fn (pointer: *Pointer, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Pointer,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn setCursor(self: *Pointer, _serial: u32, _surface: ?*Surface, _hotspot_x: i32, _hotspot_y: i32) void {
        var _args = [_]Argument{
            .{ .uint = _serial },
            .{ .o = @ptrCast(_surface) },
            .{ .int = _hotspot_x },
            .{ .int = _hotspot_y },
        };
        self.proxy.marshal(0, &_args);
    }
    pub fn release(self: *Pointer) void {
        self.proxy.marshal(1, null);
        // self.proxy.destroy();
    }
    pub fn destroy(self: *Pointer) void {
        self.proxy.destroy();
    }
};
pub const Keyboard = struct {
    proxy: Proxy,
    pub const generated_version = 9;
    pub const KeymapFormat = enum(c_int) {
        no_keymap = 0,
        xkb_v1 = 1,
        _,
    };
    pub const KeyState = enum(c_int) {
        released = 0,
        pressed = 1,
        _,
    };
    pub const Event = union(enum) {
        keymap: struct {
            format: KeymapFormat,
            fd: i32,
            size: u32,
        },
        enter: struct {
            serial: u32,
            surface: ?*Surface,
            keys: *anyopaque,
        },
        leave: struct {
            serial: u32,
            surface: ?*Surface,
        },
        key: struct {
            serial: u32,
            time: u32,
            key: u32,
            state: KeyState,
        },
        modifiers: struct {
            serial: u32,
            mods_depressed: u32,
            mods_latched: u32,
            mods_locked: u32,
            group: u32,
        },
        repeat_info: struct {
            rate: i32,
            delay: i32,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Keyboard,
        comptime T: type,
        comptime _listener: fn (keyboard: *Keyboard, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Keyboard,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn release(self: *Keyboard) void {
        self.proxy.marshal(0, null);
        // self.proxy.destroy();
    }
    pub fn destroy(self: *Keyboard) void {
        self.proxy.destroy();
    }
};
pub const Touch = struct {
    proxy: Proxy,
    pub const generated_version = 9;
    pub const Event = union(enum) {
        down: struct {
            serial: u32,
            time: u32,
            surface: ?*Surface,
            id: i32,
            x: Fixed,
            y: Fixed,
        },
        up: struct {
            serial: u32,
            time: u32,
            id: i32,
        },
        motion: struct {
            time: u32,
            id: i32,
            x: Fixed,
            y: Fixed,
        },
        frame: void,
        cancel: void,
        shape: struct {
            id: i32,
            major: Fixed,
            minor: Fixed,
        },
        orientation: struct {
            id: i32,
            orientation: Fixed,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Touch,
        comptime T: type,
        comptime _listener: fn (touch: *Touch, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Touch,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn release(self: *Touch) void {
        self.proxy.marshal(0, null);
        // self.proxy.destroy();
    }
    pub fn destroy(self: *Touch) void {
        self.proxy.destroy();
    }
};
pub const Output = struct {
    proxy: Proxy,
    pub const generated_version = 4;
    pub const Subpixel = enum(c_int) {
        unknown = 0,
        none = 1,
        horizontal_rgb = 2,
        horizontal_bgr = 3,
        vertical_rgb = 4,
        vertical_bgr = 5,
        _,
    };
    pub const Transform = enum(c_int) {
        normal = 0,
        @"90" = 1,
        @"180" = 2,
        @"270" = 3,
        flipped = 4,
        flipped_90 = 5,
        flipped_180 = 6,
        flipped_270 = 7,
        _,
    };
    pub const Mode = packed struct(u32) {
        current: bool = false,
        preferred: bool = false,
        _padding: u30 = 0,
        pub const Enum = enum(c_int) {
            current = 0x1,
            preferred = 0x2,
            _,
        };
    };
    pub const Event = union(enum) {
        geometry: struct {
            x: i32,
            y: i32,
            physical_width: i32,
            physical_height: i32,
            subpixel: Subpixel,
            make: [*:0]const u8,
            model: [*:0]const u8,
            transform: Transform,
        },
        mode: struct {
            flags: Mode,
            width: i32,
            height: i32,
            refresh: i32,
        },
        done: void,
        scale: struct {
            factor: i32,
        },
        name: struct {
            name: [*:0]const u8,
        },
        description: struct {
            description: [*:0]const u8,
        },
    };
    pub const event_signatures = Proxy.genEventArgs(Event);
    pub inline fn setListener(
        self: *Output,
        comptime T: type,
        comptime _listener: fn (output: *Output, event: Event, data: T) void,
        _data: T,
    ) void {
        self.proxy.setListener(
            Output,
            _listener,
            @ptrCast(_data),
        );
    }
    pub fn release(self: *Output) void {
        self.proxy.marshal(0, null);
        // self.proxy.destroy();
    }
    pub fn destroy(self: *Output) void {
        self.proxy.destroy();
    }
};
pub const Subcompositor = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Error = enum(c_int) {
        bad_surface = 0,
        bad_parent = 1,
        _,
    };
};
pub const Subsurface = struct {
    proxy: Proxy,
    pub const generated_version = 1;
    pub const Error = enum(c_int) {
        bad_surface = 0,
        _,
    };
};
